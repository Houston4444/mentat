<!DOCTYPE html>
<html  dir="ltr">

    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Mentat</title>
        <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">
        <link rel="apple-touch-icon-precomposed" href="images/apple-touch-icon.png">
        <meta name="generator" content="pandoc-uikit" />
                        <title>Mentat</title>
        <style>
            :root {
                --color-text: #333;
                --color-accent: #0090c0;
                --side-width: 300px;
                --p-margin: 20px
            }
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
                /* font: inherit; */
            }
            body {
                display: flex;
                flex-direction: row;
                width: 960px;
                /* margin: var(--p-margin) auto 0; */

                font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif;
                line-height: 1.5;
                font-size: 14px;
                color: var(--color-text);
            }
            aside {
                width: var(--side-width);
                margin-right: 20px;
                background: #eee;
            }
            main {
                flex: 1;
                padding-top: var(--p-margin);
                min-width: 0;
            }

            aside ul {
                list-style: none;
            }
            aside > ul {
                list-style: none;
                position: fixed;
                top: 0;
                width: calc(var(--side-width));
                height: 100%;
                padding-top: var(--p-margin);
                overflow-y: auto;
                overflow-x: hidden;
                padding-left: 0;
                white-space: nowrap;
            }
            aside > ul > li {
                margin-left: var(--p-margin);
            }
            aside li {
                margin: 0;
            }
            ul {
                padding-left: 20px;
            }
            h1, h2, h3, ul, pre, p {
                margin-bottom: var(--p-margin);
            }
            hr {
                margin: calc(2 * var(--p-margin)) 0;
                opacity: 0.5;
            }
            a {
                text-decoration: none
            }
            aside a {
                color: inherit;
            }
            aside a:hover, main a {
                color: var(--color-accent);
            }
            h1, h2, h3 {
                padding-top: var(--p-margin);
                margin-top: calc(-1 * var(--p-margin));
            }
            .content {
                padding-left: 20px;
            }
            pre, code {
                background: #eee;
                padding: 0 2px;
                border: 1px solid rgba(0,0,0,0.05);
            }
            pre code {
                padding: 0;
                background: none;
                border: none;
            }
            .version {
                opacity: 0.5;
            }
        </style>
    </head>

    <body>

        <aside>
                        <ul>
                        <li><a href="#mentat">Mentat</a>
                        <ul>
                        <li><a href="#overview">Overview</a></li>
                        <li><a href="#install">Install</a></li>
                        <li><a href="#usage">Usage</a></li>
                        </ul></li>
                        <li><a href="#engine">Engine</a>
                        <ul>
                        <li><a href="#engine-1">Engine()</a></li>
                        <li><a href="#engine.start">Engine.start()</a></li>
                        <li><a href="#engine.stop">Engine.stop()</a></li>
                        <li><a href="#engine.restart">Engine.restart()</a></li>
                        <li><a href="#engine.autorestart">Engine.autorestart()</a></li>
                        <li><a href="#engine.add_module">Engine.add_module()</a></li>
                        <li><a href="#engine.send">Engine.send()</a></li>
                        <li><a href="#engine.add_route">Engine.add_route()</a></li>
                        <li><a href="#engine.set_route">Engine.set_route()</a></li>
                        <li><a href="#engine.set_tempo">Engine.set_tempo()</a></li>
                        <li><a href="#engine.set_cycle_length">Engine.set_cycle_length()</a></li>
                        <li><a href="#engine.start_cycle">Engine.start_cycle()</a></li>
                        <li><a href="#engine.dispatch_event">Engine.dispatch_event()</a></li>
                        </ul></li>
                        <li><a href="#module">Module</a>
                        <ul>
                        <li><a href="#module-1">Module()</a></li>
                        <li><a href="#module.add_submodule">Module.add_submodule()</a></li>
                        <li><a href="#module.set_aliases">Module.set_aliases()</a></li>
                        <li><a href="#module.add_parameter">Module.add_parameter()</a></li>
                        <li><a href="#module.get">Module.get()</a></li>
                        <li><a href="#module.set">Module.set()</a></li>
                        <li><a href="#module.reset">Module.reset()</a></li>
                        <li><a href="#module.animate">Module.animate()</a></li>
                        <li><a href="#module.stop_animate">Module.stop_animate()</a></li>
                        <li><a href="#module.add_condition">Module.add_condition()</a></li>
                        <li><a href="#module.get_condition">Module.get_condition()</a></li>
                        <li><a href="#module.set_condition">Module.set_condition()</a></li>
                        <li><a href="#module.send_state">Module.send_state()</a></li>
                        <li><a href="#module.save">Module.save()</a></li>
                        <li><a href="#module.load">Module.load()</a></li>
                        <li><a href="#module.route">Module.route()</a></li>
                        <li><a href="#module.send">Module.send()</a></li>
                        <li><a href="#module.add_event_callback">Module.add_event_callback()</a></li>
                        <li><a href="#module.start_scene">Module.start_scene()</a></li>
                        <li><a href="#module.stop_scene">Module.stop_scene()</a></li>
                        <li><a href="#module.wait">Module.wait()</a></li>
                        <li><a href="#module.wait_next_cycle">Module.wait_next_cycle()</a></li>
                        </ul></li>
                        <li><a href="#route">Route</a>
                        <ul>
                        <li><a href="#route-1">Route()</a></li>
                        <li><a href="#route.activate">Route.activate()</a></li>
                        <li><a href="#route.deactivate">Route.deactivate()</a></li>
                        <li><a href="#route.route">Route.route()</a></li>
                        <li><a href="#route.start_scene">Route.start_scene()</a></li>
                        <li><a href="#route.stop_scene">Route.stop_scene()</a></li>
                        <li><a href="#route.wait">Route.wait()</a></li>
                        <li><a href="#route.wait_next_cycle">Route.wait_next_cycle()</a></li>
                        </ul></li>
                        </ul>
                    </aside>

        <main>
<h2 id="mentat">Mentat</h2>
<div class="version">
<p>Version: 1.0.0-alpha (WORK IN PROGRESS)</p>
</div>
<h3 id="overview">Overview</h3>
<p>Mentat is a HUB / Conductor for OSC / MIDI capable softwares. It aims to centralize all controls in one place, manage their state and create routings.</p>
<p>Mentat is a module for <a href="https://www.python.org/">python 3</a> and requires writing code to work. If you’re looking for a fully-featured software with a user interface, try <a href="https://benjamin.kuperberg.fr/chataigne/en">Chateigne</a> instead.</p>
<h3 id="install">Install</h3>
<pre><code>git clone https://github.com/jean-emmanuel/mentat/
cd mentat
python3 setup.py install</code></pre>
<h3 id="usage">Usage</h3>
<p>The typical use case for Mentat is a conductor for controlling a set of softwares during a live performance.</p>
<p>The <a href="#engine"><code>Engine</code></a> object is the main object, it manages the OSC / MIDI backends, the modules and the routes. It also holds a tempo, a cycle length (measure) and a time reference that’s used to create timed scenes and sequences in a musical way (using beats instead of seconds).</p>
<p><a href="#module"><code>Module</code></a> objects are interfaces between the controlled softwares and the engine. The <code>Module</code> class should be subclassed to create dedicated module classes for different softwares.</p>
<p>A set of controllable parameters can be defined for each module, each parameter being an alias for an OSC / MIDI value in the controlled software.</p>
<p>Controlled parameters should only modified using the module’s <a href="#module.set"><code>set()</code></a> and <a href="#module.animate"><code>animate()</code></a> methods in order to guarantee that the state of the modules reflects the actual state of the softwares. This removes the need for feedback from said softwares and allows us to trust Mentat as the source of truth during the performance.</p>
<p>All messages received by the engine that are coming from a software associated with a module are first passed to that module’s <a href="#module.route"><code>route()</code></a> method.</p>
<p><a href="#route"><code>Route</code></a> objects represent the different parts of the performance (eg tracks / songs in a musical show). The <code>Engine</code> has one active route at a time and will pass all incoming messages to its <a href="#route.route"><code>route()</code></a> method.</p>
<p>Each track should be a dedicated class derived from the <code>Route</code> class. The <a href="#route.route"><code>route()</code></a> method definition will allow writing the actual routing that should occur during that track.</p>
<hr />
<h2 id="engine">Engine</h2>
<p>Main object</p>
<p><strong>Instance properties</strong></p>
<ul>
<li><code>modules</code>: <code>dict</code> containing modules added to the engine with names as keys</li>
<li><code>restarted</code>: <code>True</code> if the engine was restarted using <code>autorestart()</code></li>
<li><code>logger</code>: python logger</li>
</ul>
<h3 id="engine-1">Engine()</h3>
<div class="content">
<p><i>Engine(name, port, folder)</i><br/></p>
<p>Engine constructor.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: client name</li>
<li>port: osc input port, can be an udp port number or a unix socket path</li>
<li>folder: path to config folder where state files will be saved to and loaded from</li>
<li>debug: set to True to enable debug messages</li>
</ul>
</div>
<h3 id="engine.start">Engine.start()</h3>
<div class="content">
<p><i>start()</i><br/></p>
<p>Start engine.</p>
</div>
<h3 id="engine.stop">Engine.stop()</h3>
<div class="content">
<p><i>stop()</i><br/></p>
<p>Stop engine.</p>
</div>
<h3 id="engine.restart">Engine.restart()</h3>
<div class="content">
<p><i>restart()</i><br/></p>
<p>Stop the engine and restart once the process is terminated.</p>
</div>
<h3 id="engine.autorestart">Engine.autorestart()</h3>
<div class="content">
<p><i>autorestart()</i><br/></p>
<p>Watch main script and imported modules and call restart when they change.</p>
</div>
<h3 id="engine.add_module">Engine.add_module()</h3>
<div class="content">
<p><i>add_module(module)</i><br/></p>
<p>Add a module.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>module: Module object</li>
</ul>
</div>
<h3 id="engine.send">Engine.send()</h3>
<div class="content">
<p><i>send(protocol, port, address, *args)</i><br/></p>
<p>Send OSC / MIDI message.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>protocol: ‘osc’ or ‘midi’</li>
<li>port: module name or udp port number or unix socket path if protocol is ‘osc’</li>
<li>address: osc address</li>
<li>args: values</li>
</ul>
</div>
<h3 id="engine.add_route">Engine.add_route()</h3>
<div class="content">
<p><i>add_route(route)</i><br/></p>
<p>Add a route.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>route: Route object</li>
</ul>
</div>
<h3 id="engine.set_route">Engine.set_route()</h3>
<div class="content">
<p><i>set_route(name)</i><br/></p>
<p>Set active route.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: route name</li>
</ul>
</div>
<h3 id="engine.set_tempo">Engine.set_tempo()</h3>
<div class="content">
<p><i>set_tempo(bpm)</i><br/></p>
<p>Set engine tempo.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>bpm: beats per minute</li>
</ul>
</div>
<h3 id="engine.set_cycle_length">Engine.set_cycle_length()</h3>
<div class="content">
<p><i>set_cycle_length(eighth_notes)</i><br/></p>
<p>Set engine cycle (measure) length.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>eighth_notes: eighth notes per cycle</li>
</ul>
</div>
<h3 id="engine.start_cycle">Engine.start_cycle()</h3>
<div class="content">
<p><i>start_cycle()</i><br/></p>
<p>Set current time as cycle start. Affects Route.wait_next_cycle() method.</p>
</div>
<h3 id="engine.dispatch_event">Engine.dispatch_event()</h3>
<div class="content">
<p><i>dispatch_event(event, *args)</i><br/></p>
<p>Dispatch event to bound callback functions.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>event: name of event</li>
<li>*args: arguments for the callback function</li>
</ul>
</div>
<hr />
<h2 id="module">Module</h2>
<p>Interface between a software / hardware and the engine.</p>
<p><strong>Instance properties</strong></p>
<ul>
<li><code>engine</code>: Engine instance</li>
<li><code>logger</code>: python logger</li>
<li><code>name</code>: module name</li>
<li><code>parent_module</code>: parent module instance, <code>None</code> if the module is not a submodule</li>
<li><code>module_path</code>: list of module names, from topmost parent to submodule</li>
</ul>
<h3 id="module-1">Module()</h3>
<div class="content">
<p><i>Module(engine, name, protocol=None, port=None, parent=None)</i><br/></p>
<p>Base Module constructor. Arguments protocol and port should be omitted only when the module is a submodule.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: module name</li>
<li>protocol: ‘osc’ or ‘midi’</li>
<li>port: udp port number or unix socket path if protocol is ‘osc’ can be None if the module has no fixed input port</li>
<li>parent: if the module is a submodule, this must be set to the parent module’s instance</li>
</ul>
</div>
<h3 id="module.add_submodule">Module.add_submodule()</h3>
<div class="content">
<p><i>add_submodule(module)</i><br/></p>
<p>Add a submodule. Submodule’s protocol and port can be omitted, in which case they will be inherited from their parent. The submodule’s parent instance must be provided in its constructor function (<code>parent</code> argument).</p>
<p><strong>Parameters</strong></p>
<ul>
<li>module: Module object</li>
</ul>
</div>
<h3 id="module.set_aliases">Module.set_aliases()</h3>
<div class="content">
<p><i>set_aliases(aliases)</i><br/></p>
<p>Set aliases for submodules. Aliases can be used in place of the submodule_name argument in some methods.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>aliases: {alias: name} dictionary</li>
</ul>
</div>
<h3 id="module.add_parameter">Module.add_parameter()</h3>
<div class="content">
<p><i>add_parameter(name, address, types, static_args=[], default=None)</i><br/></p>
<p>Add parameter to module.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: name of parameter</li>
<li>address: osc address of parameter</li>
<li>types: osc typetags string, one letter per value, including static values</li>
<li>static_args: list of static values before the ones that can be modified</li>
<li>default: value or list of values if the parameter has multiple dynamic values</li>
</ul>
</div>
<h3 id="module.get">Module.get()</h3>
<div class="content">
<p><i>get(parameter_name)</i><br/> <i>get(submodule_name, param_name)</i><br/></p>
<p>Get value of parameter</p>
<p><strong>Parameters</strong></p>
<ul>
<li>parameter_name: name of parameter</li>
<li>submodule_name: name of submodule</li>
</ul>
<p><strong>Return</strong></p>
<p>List of values</p>
</div>
<h3 id="module.set">Module.set()</h3>
<div class="content">
<p><i>set(parameter_name, <em>args)</i><br/> <i>set(submodule_name, param_nam, </em>args)</i><br/></p>
<p>Set value of parameter. Schedule a message if the new value differs from the one in memory.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>parameter_name: name of parameter</li>
<li>submodule_name: name of submodule</li>
<li>*args: value(s)</li>
</ul>
</div>
<h3 id="module.reset">Module.reset()</h3>
<div class="content">
<p><i>reset(name=None)</i><br/></p>
<p>Reset parameter to its default values.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: name of parameter. If omitted, affects all parameters including submodules’</li>
</ul>
</div>
<h3 id="module.animate">Module.animate()</h3>
<div class="content">
<p><i>animate(parameter_name, start, end, duration, mode=‘seconds’, easing=‘linear’)</i><br/> <i>animate(submodule_name, parameter_name, start, end, duration, mode=‘beats’, easing=‘linear’)</i><br/></p>
<p>Animate parameter.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>parameter_name: name of parameter</li>
<li>submodule_name: name of submodule</li>
<li>start: starting value(s), can be None to use currnet value</li>
<li>end: ending value(s)</li>
<li>duration: animation duration</li>
<li>mode: ‘seconds’ or ‘beats’</li>
<li>easing: easing function name</li>
</ul>
</div>
<h3 id="module.stop_animate">Module.stop_animate()</h3>
<div class="content">
<p><i>stop_animate(parameter_name)</i><br/> <i>stop_animate(submodule_name, param_name)</i><br/></p>
<p>Stop parameter animation.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>parameter_name: name of parameter, can be ’*’ to stop all animations.</li>
<li>submodule_name: name of submodule, name of parameter</li>
</ul>
</div>
<h3 id="module.add_condition">Module.add_condition()</h3>
<div class="content">
<p><i>add_condition(name, parameters, callback)</i><br/></p>
<p>Add a condition property whose value depends on the state of one or several parameters owned by the module or its submodules.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: name of condition</li>
<li>parameters: list of parameter names involved in the condition. Items may be lists if the parameters are owned by a submodule (<code>['submodule_name', 'parameter_name']</code>)</li>
<li>getter: callback function that will be called with the values of involved parameters as arguments. Its return value will define the condition’s state.</li>
<li>setter: callback function used to set the value of the parameters involved in the condition when <code>set_condition()</code> is called. It receives as argument the condition’s state and must set involved parameters accordingly.</li>
</ul>
</div>
<h3 id="module.get_condition">Module.get_condition()</h3>
<div class="content">
<p><i>get_condition(condition_name)</i><br/> <i>get_condition(submodule_name, condition_name)</i><br/></p>
<p>Get value of condition</p>
<p><strong>Parameters</strong></p>
<ul>
<li>condition_name: name of condition</li>
<li>submodule_name: name of submodule</li>
</ul>
<p><strong>Return</strong></p>
<p>State of condition, depends on the callback function provided in <code>add_condition(</code>).</p>
</div>
<h3 id="module.set_condition">Module.set_condition()</h3>
<div class="content">
<p><i>set_condition(condition_name, state)</i><br/> <i>set_condition(submodule_name, condition_name, state)</i><br/></p>
<p>Set value of condition</p>
<p><strong>Parameters</strong></p>
<ul>
<li>condition_name: name of condition</li>
<li>submodule_name: name of submodule</li>
<li>state: state of the condition passed to the condition’s setter function</li>
</ul>
</div>
<h3 id="module.send_state">Module.send_state()</h3>
<div class="content">
<p><i>send_state()</i><br/></p>
<p>Send current state of all parameters and submodules’ parameters.</p>
</div>
<h3 id="module.save">Module.save()</h3>
<div class="content">
<p><i>save(name)</i><br/></p>
<p>Save current state (including submodules) to file.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: name of state save (without file extension)</li>
</ul>
</div>
<h3 id="module.load">Module.load()</h3>
<div class="content">
<p><i>load(name)</i><br/></p>
<p>Load state from memory or from file if not preloaded already</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: name of state save (without file extension)</li>
</ul>
</div>
<h3 id="module.route">Module.route()</h3>
<div class="content">
<p><i>route(address, args)</i><br/></p>
<p>Route messages received by the engine on the module’s port. Does nothing by default, method should be overriden in subclasses. Not called on submodules.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>address: osc address</li>
<li>args: list of values</li>
</ul>
<p><strong>Return</strong></p>
<p><code>False</code> if the message should not be passed to the engine’s active route after being processed by the module.</p>
</div>
<h3 id="module.send">Module.send()</h3>
<div class="content">
<p><i>send(address, *args)</i><br/></p>
<p>Send message to the module’s port.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>address: osc address</li>
<li>*args: values</li>
</ul>
</div>
<h3 id="module.add_event_callback">Module.add_event_callback()</h3>
<div class="content">
<p><i>add_event_callback(event, callback)</i><br/></p>
<p>Bind a callback function to an event.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>event: name of event</li>
<li>callback: function or method. The callback’s signature must match the event’s arguments.</li>
</ul>
<p><strong>Events</strong></p>
<ul>
<li><code>engine_started</code>: emitted when the engine starts.</li>
<li><code>engine_stopping</code>: emitted before the engine stops</li>
<li><code>engine_stopped</code>: emitted when the engine is stopped</li>
<li><code>parameter_changed</code>: emitted when a module’s parameter changes. Arguments:
<ul>
<li>module: instance of module that emitted the event</li>
<li>name: name of parameter</li>
<li>value: value of parameter or list of values</li>
</ul></li>
<li><code>condition_changed</code>: emitted when a module’s condition changes. Arguments:
<ul>
<li>module: instance of module that emitted the event</li>
<li>name: name of condition</li>
<li>value: value</li>
</ul></li>
</ul>
</div>
<h3 id="module.start_scene">Module.start_scene()</h3>
<div class="content">
<p><i>start_scene(name, scene, *args, **kwargs)</i><br/></p>
<p>Start scene in a thread. If a scene with the same name is already running, it will be stopped. Scenes should be implemented as methods of the object and can call self.wait() to create timed sequences or loops. Different objects may call a scene with the same name simultaneously.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: scene name</li>
<li>scene: function or method</li>
<li>*args: arguments for the scene function</li>
<li>**kwargs: keyword arguments for the scene function</li>
</ul>
</div>
<h3 id="module.stop_scene">Module.stop_scene()</h3>
<div class="content">
<p><i>stop_scene(name)</i><br/></p>
<p>Stop scene thread.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: scene name, with wildcard support</li>
</ul>
</div>
<h3 id="module.wait">Module.wait()</h3>
<div class="content">
<p><i>wait(duration, mode=‘beats’)</i><br/></p>
<p>Wait for given amount of time. Can only called in scenes. Subsequent calls to wait() in a scene do not drift with time and can be safely used to create beat sequences. The engine’s <code>tempo</code> must be set for the <code>beats</code> mode to work.</p>
<pre><code># Example
beat_1()
self.wait(1, &#39;b&#39;) # will wait 1 beat minus beat_1&#39;s exec time
beat_2()
self.wait(1, &#39;b&#39;) # will wait 1 beat minus beat_1 and beat_2&#39;s exec time</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li>duration: amount of time to wait</li>
<li>mode: ‘beats’ or ‘seconds’ (only the first letter matters)</li>
</ul>
</div>
<h3 id="module.wait_next_cycle">Module.wait_next_cycle()</h3>
<div class="content">
<p><i>wait_next_cycle()</i><br/></p>
<p>Wait until next cycle begins. The engine’s <code>tempo</code> and <code>cycle_length</code> must be set and the engine’s <code>start_cycle()</code> method must be called at the beginning of a cycle for this to work.</p>
</div>
<hr />
<h2 id="route">Route</h2>
<p>Routing object that processes messages received by the engine when active.</p>
<p><strong>Instance properties</strong></p>
<ul>
<li><code>engine</code>: Engine instance</li>
<li><code>logger</code>: python logger</li>
</ul>
<h3 id="route-1">Route()</h3>
<div class="content">
<p><i>Route()</i><br/></p>
<p>Route object constructor.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: roustart_scte name</li>
</ul>
</div>
<h3 id="route.activate">Route.activate()</h3>
<div class="content">
<p><i>activate()</i><br/></p>
<p>Called when the engine switches to this route.</p>
</div>
<h3 id="route.deactivate">Route.deactivate()</h3>
<div class="content">
<p><i>deactivate()</i><br/></p>
<p>Called when the engine switches to another route.</p>
</div>
<h3 id="route.route">Route.route()</h3>
<div class="content">
<p><i>route(protocol, port, address, args)</i><br/></p>
<p>Process messages received by the engine.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>protocol: ‘osc’ or ‘midi’</li>
<li>port: name of module or port number if unknown</li>
<li>address: osc address</li>
<li>args: list of values</li>
</ul>
</div>
<h3 id="route.start_scene">Route.start_scene()</h3>
<div class="content">
<p><i>start_scene(name, scene, *args, **kwargs)</i><br/></p>
<p>Start scene in a thread. If a scene with the same name is already running, it will be stopped. Scenes should be implemented as methods of the object and can call self.wait() to create timed sequences or loops. Different objects may call a scene with the same name simultaneously.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: scene name</li>
<li>scene: function or method</li>
<li>*args: arguments for the scene function</li>
<li>**kwargs: keyword arguments for the scene function</li>
</ul>
</div>
<h3 id="route.stop_scene">Route.stop_scene()</h3>
<div class="content">
<p><i>stop_scene(name)</i><br/></p>
<p>Stop scene thread.</p>
<p><strong>Parameters</strong></p>
<ul>
<li>name: scene name, with wildcard support</li>
</ul>
</div>
<h3 id="route.wait">Route.wait()</h3>
<div class="content">
<p><i>wait(duration, mode=‘beats’)</i><br/></p>
<p>Wait for given amount of time. Can only called in scenes. Subsequent calls to wait() in a scene do not drift with time and can be safely used to create beat sequences. The engine’s <code>tempo</code> must be set for the <code>beats</code> mode to work.</p>
<pre><code># Example
beat_1()
self.wait(1, &#39;b&#39;) # will wait 1 beat minus beat_1&#39;s exec time
beat_2()
self.wait(1, &#39;b&#39;) # will wait 1 beat minus beat_1 and beat_2&#39;s exec time</code></pre>
<p><strong>Parameters</strong></p>
<ul>
<li>duration: amount of time to wait</li>
<li>mode: ‘beats’ or ‘seconds’ (only the first letter matters)</li>
</ul>
</div>
<h3 id="route.wait_next_cycle">Route.wait_next_cycle()</h3>
<div class="content">
<p><i>wait_next_cycle()</i><br/></p>
<p>Wait until next cycle begins. The engine’s <code>tempo</code> and <code>cycle_length</code> must be set and the engine’s <code>start_cycle()</code> method must be called at the beginning of a cycle for this to work.</p>
</div>
<hr />
        </main>

    </body>
</html>
